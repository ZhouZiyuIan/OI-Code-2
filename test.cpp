#include <cstring>
#include <iostream>
#include <map>
using namespace std;
constexpr int MAXN = 2000010;
long long T, n, pri[MAXN], cur, mu[MAXN], sum_mu[MAXN];
bool vis[MAXN];
map<long long, long long> mp_mu;

long long S_mu(long long x) {  // 求mu的前缀和
	if (x < MAXN) return sum_mu[x];
	if (mp_mu[x]) return mp_mu[x];  // 如果map中已有该大小的mu值，则可直接返回
	long long ret = (long long)1;
	for (long long i = 2, j; i <= x; i = j + 1) {
		j = x / (x / i);
		ret -= S_mu(x / i) * (j - i + 1);
	}
	return mp_mu[x] = ret;  // 路径压缩，方便下次计算
}

long long S_phi(long long x) {  // 求phi的前缀和
	long long ret = (long long)0;
	long long j;
	for (long long i = 1; i <= x; i = j + 1) {
		j = x / (x / i);
		ret += (S_mu(j) - S_mu(i - 1)) * (x / i) * (x / i);
	}
	return (ret - 1) / 2 + 1;
}

int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> T;
	mu[1] = 1;
	for (int i = 2; i < MAXN; i++) {  // 线性筛预处理mu数组
		if (!vis[i]) {
			pri[++cur] = i;
			mu[i] = -1;
		}
		for (int j = 1; j <= cur && i * pri[j] < MAXN; j++) {
			vis[i * pri[j]] = true;
			if (i % pri[j])
				mu[i * pri[j]] = -mu[i];
			else {
				mu[i * pri[j]] = 0;
				break;
			}
		}
	}
	for (int i = 1; i < MAXN; i++)
		sum_mu[i] = sum_mu[i - 1] + mu[i];  // 求mu数组前缀和
	while (T--) {
		cin >> n;
		cout << S_phi(n) << ' ' << S_mu(n) << '\n';
	}
	return 0;
}